# ðŸ“š Kotlin -  ê³ ì°¨ í•¨ìˆ˜

> ðŸ’¡ê³ ì°¨ í•¨ìˆ˜ëŠ” íŒŒë¼ë¯¸í„°ë¡œ í•¨ìˆ˜ë¥¼ ë°›ê±°ë‚˜, í•¨ìˆ˜ë¥¼ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜

## ðŸ‘»ê³ ì°¨ í•¨ìˆ˜ëž€?
- íŒŒë¼ë¯¸í„°ë¡œ í•¨ìˆ˜ë¥¼ ë°›ê±°ë‚˜, í•¨ìˆ˜ë¥¼ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜
---
- `add`í•¨ìˆ˜ëŠ” íŒŒë¼ë¯¸í„°ë¡œ ì •ìˆ˜ 2ê°œë¥¼ ë°›ê³ , ì •ìˆ˜ 1ê°œë¥¼ ë°˜í™˜í•œë‹¤.
- íŒŒë¼ë¯¸í„° íƒ€ìž…ì´ë‚˜ ë°˜í™˜ íƒ€ìž…ì— í•¨ìˆ˜ê°€ ì—†ê¸° ë•Œë¬¸ì— ê³ ì°¨ í•¨ìˆ˜ê°€ ì•„ë‹ˆë‹¤.
```kotlin
// ì •ìˆ˜ë¥¼ ë°›ì•„ ì •ìˆ˜ë¥¼ ë°˜í™˜í•˜ê¸°ì— ê³ ì°¨í•¨ìˆ˜ê°€ ì•„ë‹ˆë‹¤.
fun add(num1: Int, num2: Int): Int {
    return num1 + num2
}
```
---

- `compute`í•¨ìˆ˜ëŠ” íŒŒë¼ë¯¸í„°ë¡œ ì •ìˆ˜ 2ê°œì™€ í•¨ìˆ˜ 1ê°œë¥¼ ë°›ê³ , ì •ìˆ˜ 1ê°œë¥¼ ë°˜í™˜í•œë‹¤.
- ì¦‰, íŒŒë¼ë¯¸í„°ì— í•¨ìˆ˜ê°€ ì¡´ìž¬í•˜ê¸° ë•Œë¬¸ì— `compute`í•¨ìˆ˜ëŠ” ê³ ì°¨í•¨ìˆ˜ì´ë‹¤.
- `op`ë¼ëŠ” íŒŒë¼ë¯¸í„°ë¥¼ ë³´ë©´, `(Int, Int) -> Int`ë¼ëŠ” íƒ€ìž…ì„ ê°€ì§€ê³  ìžˆëŠ”ë° ì •ìˆ˜ 2ê°œë¥¼ ë°›ì•„ ì •ìˆ˜ 1ê°œë¥¼ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ íƒ€ìž…ì„ ì˜ë¯¸í•œë‹¤.
```kotlin
fun compute(num1: Int, num2: Int, op: (Int, Int) -> Int): Int {
    return op(num1 ,num2)
}
```
---

- ë°˜í™˜ íƒ€ìž…ì—ë„ í•¨ìˆ˜ê°€ ë“¤ì–´ê°ˆ ìˆ˜ ìžˆë‹¤.
- `opGenerator` í•¨ìˆ˜ëŠ” íŒŒë¼ë¯¸í„°ë¡œ ì•„ë¬´ê²ƒë„ ë°›ì§€ ì•Šì§€ë§Œ, `(Int, Int) -> Int` í•¨ìˆ˜ë¥¼ ë°˜í™˜í•˜ê³  ìžˆë‹¤. 
- `onGenerator` í•¨ìˆ˜ ì—­ì‹œ ê³ ì°¨í•¨ìˆ˜ì´ë‹¤.
```kotlin
fun opGenerator(): (Int, Int) -> Int {
    TODO("í•¨ìˆ˜ êµ¬í˜„ì´ ë˜ì§€ ì•Šì•˜ë‹¤")
}
```

## ðŸŽ¯ê³ ì°¨í•¨ìˆ˜ í˜¸ì¶œ ë°©ë²•
#### ë°©ë²•1. ëžŒë‹¤ì‹
- í˜¸ì¶œí•˜ëŠ” í•¨ìˆ˜ ë§ˆì§€ë§‰ íŒŒë¼ë¯¸í„°ì— ëžŒë‹¤ì‹ì´ ë“¤ì–´ê°€ëŠ” ê²½ìš°ëŠ” ëžŒë‹¤ì‹ì„ í•¨ìˆ˜ í˜¸ì¶œ ë¶€ë¶„ ë°”ê¹¥ìœ¼ë¡œ ëº„ ìˆ˜ ìžˆë‹¤. 
- ë‹¨ì  : ë¦¬í„´ì„ í•  ìˆ˜ ì—†ë‹¤.
```kotlin
// ëžŒë‹¤ì‹ì„ í™œìš©í•˜ëŠ” ë°©ë²•
compute(5, 3 { a, b -> a + b })

// ëžŒë‹¤ì‹ì„ í•¨ìˆ˜ í˜¸ì¶œ ë¶€ë¶„ ë°”ê¹¥ìœ¼ë¡œ ëº„ ìˆ˜ ìžˆìŒ
compute(5, 3) { a, b -> a + b }
```
--- 
#### ë°©ë²•2. ìµëª… í•¨ìˆ˜
- ìµëª… í•¨ìˆ˜ëŠ” ìš°ë¦¬ê°€ ìµìˆ™í•˜ê²Œ ìž‘ì„±í•˜ëŠ” í•¨ìˆ˜ì—ì„œ í•¨ìˆ˜ ì´ë¦„ë§Œ ë¹ ì§„ í˜•íƒœì´ë‹¤.
- ìµëª… í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•  ë•Œ ë¬¸ë§¥ì„ í†µí•´ íŒŒë¼ë¯¸í„° íƒ€ìž…ì„ ì¶”ë¡ í•  ìˆ˜ ìžˆë‹¤ë©´, íŒŒë¼ë¯¸í„° íƒ€ìž… ì§€ì •ì„ ìƒëžµí•  ìˆ˜ë„ ìžˆë‹¤.
```kotlin
// ìµëª… í•¨ìˆ˜ë¥¼ í™œìš©í•˜ëŠ” ë°©ë²•
compute(5, 3, fun(a, b): Int = a + b)

// ìµëª… í•¨ìˆ˜ë¥¼ ê°€ìž¥ ê°„ë‹¨ížˆ ë§Œë“  ë°©ë²•
compute(5, 3, fun(a, b) = a + b)
```

## ðŸŽ±Enum classê°€ í•¨ìˆ˜ë¥¼ ê°–ë„ë¡ ì„¤ì •
- `calculate`í•¨ìˆ˜ëŠ” `Operator`íƒ€ìž…ì„ ì¸ìžë¡œ ë°›ì•„, `calcFun`(ê³ ì°¨ í•¨ìˆ˜)ì„ í˜¸ì¶œí•´ì„œ ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
- ì¦‰, ì „ë‹¬ëœ ì—°ì‚°ìžì— ë”°ë¼ ê³„ì‚° ë°©ì‹ì´ ë‹¬ë¼ì§‘ë‹ˆë‹¤.
- ì´ êµ¬ì¡°ì˜ ìž¥ì ì€ ì—°ì‚°ì´ ë§Žì•„ì ¸ë„ enum í•˜ë‚˜ë§Œ ìˆ˜ì •í•˜ë©´ ë˜ë¯€ë¡œ ìœ ì§€ë³´ìˆ˜ì™€ í™•ìž¥ì„±ì´ ì¢‹ë‹¤

```kotlin
enum class Operator(
    private val oper: Char,
    val calcFun: (Int, Int) -> Int, // ê³ ì°¨ í•¨ìˆ˜
) {
    PLUS('+', { a, b -> a + b }),
    MINUS('-', { a, b -> a - b }),
    MULTIPLY('*', { a, b -> a * b }),
    DIVIDE('/', { a, b ->
        if (b == 0) {
            throw IllegalArgumentException("0ìœ¼ë¡œ ë‚˜ëˆŒ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
        } else {
            a / b
        }
    })
}

fun calculate(num1: Int, num2: Int, oper: Operator) = 
    oper.calcFun(num1, num2)

fun main(){
    val result = calculate(10, 5, Operator.PLUS) // 10 + 5 = 15
    val result = calculate(10, 5, Operator.MINUS) // 10 - 5 = 5
}
```


