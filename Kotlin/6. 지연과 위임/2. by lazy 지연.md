# 📚 Kotlin - by lazy - 지연 초기화 1회 로직

> 💡`by lazy`은 처음 접근시 자동으로 초기화되는 불변 변수용 지연 입니다.

## 📁요구사항
객체의 인스턴스화 시점과 초기화 시점을 분리하되, 최초로 변수를 사용할 때 지정된 로직을 1회만 실행시켜 값을 가져오고 싶다.
- 특정 값을 가져오는 비용이 크고, 해당 변수가 사용되지 않을 수도 있다면, 이런 특성이 필요해진다.


## 📘예시 문제
- 문제 : 사람의 이름을 File에서 읽어야 하고 Disk I/O를 거치는데 2초가 걸린다고 하자. `Thread.sleep(2_000)`은 Disk I/O를 대신한다.

1. `<방법 1>`은 `name`을 사용하지 않으면 `Thread.sleep`이 호출되지 않는 장점이 있다. 하지만, `name`이 사용될 때마다 `Thread.sleep`이 호출되기 때문에 `name`을 쓰면 쓸수록 I/O가 발생한다.
2. `<방법 2>`는 `Thread.sleep`이 한 번만 호출된다. 하지만, `name`이 필요하지 않은 경우에도 `Thread.sleep`이 호출되는 손해가 발생한다.

```kotlin
// 방법 1
class Person {
    val name: String
        get() {
        Thread.sleep(2_000)
        return "김수한무"
    }
}
// 방법 2
class Person {
    val name: String
    init {
        Thread.sleep(2_000)
        name = "김수한무"
    }
}
```
우리의 요구사항을 보다 명확히 구현하려면 아래 `<방법 3>`처럼 `backing property`를 활용해야 한다.
- `_name`즉, `backing property`가 `null`이라면 값이 초기화되지 않았다 라고 생각해서 실제 초기화 로직을 실행 한후
- `backing property`에 `"김수한무"`를 담아주고 리턴을 해준다.
- 이렇게 하면 처음 한번 호출될때 `backing property`가 `null`일테니 초기화가 실행되고, 그 이후에는 반복적으로 `name`이 호출된다.
```kotlin
// 방법 3
class Person {
    // name과 대응되는, 외부로 드러나지 않는 프로퍼티 : backing property (뒤에서 도와주는 또 다른 property)
    private var _name: String? = null
    val name: String
        get() {
        if (_name == null) {
            Thread.sleep(2_000)
            this._name = "김수한무"
        }
        return _name!!
    }
}
```

하지만 당연히 이런 긴 코드를 매번 작성하는 것은 무척 번거롭다. 이럴 때 바로 by lazy 를 사용할 수 있다.

## 🎉해결 방법 `by lazy` 지연 초기화 1회 로직
- 여기서 `lazy`는 코틀린에서 제공하는 함수로, 또 다른 함수를 파라미터로 받는다.
- 우리는 이 함수에 { } 와 같은 람다를 넣어준다.
- 이 람다는 `name`의 `getter`가 최초로 호출될 때 한 번만 실행되고 기본적으로 `Thread-Safe`하게 동작한다.
- 방법3 `backing property`보다 간결한 방법으로 우리의 목표를 달성한 것이다.


```kotlin
class Person {
    val name: String by lazy {
        Thread.sleep(2_000)
        "김수한무"
    }
}
```