# 📚 Spring - Lock And Race Condition

> 💡 읽을때는 동시성 걱정이 없지만 쓰기 작업을 할때는 동시성 문제를 생각해야 한다.

## 🙊Lock 이란?
여러 커넥션들이 수정 요청이 동시에 발생하게 되면은 커넥션은 오는 순번에 따라서 데이터 값이 어떻게 될지 아무도 모른다. 
이때 데이터의 일관성에 문제가 생기게 되는데 이 문제를 해결하는 방법이 Lock이다. 
* 즉, 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 하나의 커넥션만 변경할 수 있게 해주는 기능 이다.

## 🌈동시성 예제 (재고 감소)
* 상품의 ID와 감소시킬 재고 수량을 받아서 재고를 감소시키는 `decrease` 메소드를 구현했다.
```java
@Service
@RequiredArgsConstructor
public class StockService {

	private final StockRepository stockRepository;

	@Transactional
	public void decrease(final Long id, final Long quantity) {
		final Stock stock = stockRepository.findById(id)
				.orElseThrow();
		stock.decrease(quantity);

		stockRepository.saveAndFlush(stock);
	}
}
```
* 재고 감소 테스트 메소드에서 상품 ID가 1인 상품의 재고 1만큼 감소 후 99개가 남았는지 테스트 한다.
* 아래 테스트 코드는 하나의 요청에서는 테스트가 성공하여 정상적으로 동작합니다. 
* 그러나 여러 요청이 동시에 들어왔을 때는 동작을할까?
```java
@DisplayName("재고 1감소 시킨다.")
@Test
void decrease() {
    // given
    stockRepository.save(new Stock(1L, 100L));
    // when
    stockService.decrease(1L, 1L);
    final Stock stock = stockRepository.findById(1L).orElseThrow();
    // then
    assertThat(stock.getQuantity()).isEqualTo(99);
}
```
> `CountDownLatch`는 하나 이상의 스레드가 다른 스레드에서 수행 중인 작업이 완료될 때까지 기다릴 수 있도록 하는 동기화 보조 장치입니다.
* `countDownLatch`객체를 100으로 초기화하고 100개의 스레드가 `stockService.decrease()`를 호출하도록 비동기로 요청을 보냅니다.
* 각 스레드는 작업이 끝나면 `countDown()`을 호출해서 Latch 카운트를 1 감소시킵니다.
* 그 후 `countDown()`이 0이 되는 순간 `await()`는 풀리고 다음 코드(`stockRepository.findById...`)가 실행됩니다.
> 즉 모든 스레드가 작업을 완료했다는 것을 의미


* 100개의 쓰레드를 생성해 100번 반복하여 재고를 감소 시키는 로직을 테스트 한다.
* 스레드 작업이 스레드 개수(100)만큼 실행되기 전까지 대기하고, 100개가 실행되어 `count`가 0이 되면 이후 로직 실행
* **그러면 100명이 상품을 하나씩 감소시켰으니 테스트 결과가 0으로 성공했을거 같지만 실패했다.**
> 왜 이런 상황이 생겼을까? 바로 레이스 컨디션(`Race Condition`)이 발생했기 때문입니다.
```java
@DisplayName("동시에 100개의 요청으로 재고를 감소시킨다.")
@Test
void decrease_100_request() throws InterruptedException {
	// given
	final int threadCount = 100;
	final ExecutorService executorService = Executors.newFixedThreadPool(32);
	final CountDownLatch countDownLatch = new CountDownLatch(threadCount);

	// when
	for (int i = 0; i < threadCount; i++) {
		executorService.submit(() -> {
			try {
				stockService.decrease(1L, 1L);
			} finally {
				countDownLatch.countDown();
			}
		});
	}
	countDownLatch.await();
	final Stock stock = stockRepository.findById(1L).orElseThrow();

	// then
	assertThat(stock.getQuantity()).isEqualTo(0);
}
```

## 💚레이스 컨디션(Race Condition)이란?
* 레이스 컨디션이란 둘 이상의 `Thread`가 공유 자원에 접근해서 동시에 변경을 할 때 발생하는 문제이다.
* 아래 이미지를 보면 `Thread`1, 2, 3이 모두 같은 상품에 접근합니다. 이때 `Thread`1, 2, 3이 접근한 상품의 재고는 100입니다. 
* 즉, 마지막 `Thread`3의 작업이 끝날 때 재고가 최종적으로 99로 변하는 것입니다.
> 일반적인 예상으로는 작업 하나당 제고가 1개씩 줄어서 97개의 재고가 남을거라 예상 되지만 `Race Condition`이 발생하여 재고가 정상적으로 줄지 않은 것입니다.

![Image](https://github.com/user-attachments/assets/e08a5bac-524f-48f0-9794-31a1675b98c3)


## 👀Lock 종류
* 낙관적 락 (`Optimistic Lock`)
* 비관적 락 (`Pessimistic Lock`)

## 🍋비관적 락 (`Pessimistic Lock`)
* 비관적 `Lock`은 애초에 트랜잭션이 매번 충돌이 발생한다고 가정하고 사용하는 전략이다. 
* 대표적으로 `SELECT FOR UPDATE`쿼리가 사용됩니다.
* JPA에서 비관적 Lock은 `@Lock(LockModeType.PESSIMISTIC_WRITE)`를 사용한다. 
* 조회 시점에 해당 데이터에 락을 걸어 다른 트랜잭션에서 해당 데이터를 수정하거나 읽지 못하도록 막습니다.
* 비관적 락은 락이 걸린 트랜잭션이 완료대기 까지 나머지 트랜잭션은 대기 상태가 된다. 그래서 실행중인 트랜잭션이 끝나야 다음 트랜잭션이 실행이 된다. 

```java
public interface StockRepository extends JpaRepository<Stock, Long> {

    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("select s from Stock s where s.id = :id")
    Stock findByIdWithPessimisticLock(Long id);
}
```

![Image](https://github.com/user-attachments/assets/aeb01aab-5002-4a6c-9b52-3250bde97411)

## 💣비관적 락 이슈 트러블 
* 테스트 코드 작성을 할때 `@Transactional`을 사용하는데 비관적 락은 트랜잭션 단위로 실행을 한다. 
* 즉, 테스트 코드에 `@Transactional`이 붙어 있으면 테스트 전체가 하나의 트랜잭션으로 실행되어 테스트가 끝나면 롤백이 된다.
* 이때 비관적 락은 하나의 트랜잭션이 끝나야 다음 트랜잭션한테 넘겨주는데 `@Transactional`을 붙였으니 첫 번째 트랜잭션이 끝나지 않았다.

