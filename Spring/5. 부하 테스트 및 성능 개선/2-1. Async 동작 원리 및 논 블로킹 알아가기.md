# 📚 Spring - Async 동작 원리 및 논 블로킹 알아보기
> 💡 비동기 메서드를 사용하면 서버의 성능을 향상하고 응답 시간을 줄일 수 있습니다.

## 🛁Thread Pool 이란? 
* `Thread Pool`이란 미리 일정한 수의 `Thread`를 미리 생성해서 준비해두는 메커니즘입니다.
* `Thread`생성 비용은 비싸기 때문에 미리 필요한 만큼 `Thread`를 `Pool`에 생성해 놓고, 필요할 때 꺼내서 사용합니다.
* `Thread Pool`을 적용하면, `Thread`생성 비용을 줄일 수 있다. 
* 또한 과도한 `Thread`생성을 방지할 수 있어 시스템 과부하 상태를 방지할 수 있다. 

## 🍃Thread Pool 구성 요소 
* `corePoolSize` : `Thread Pool`이 유지하는 기본 스레드 수
* `maximumPoolSize` : `Thread Pool`에서 생성 가능한 최대 스레드 수
* `keepAliveTime` : `corePoolSize`를 초과하는 스레드가 사용되지 않고 유지될 수 있는 시간
* `workQueue` : 실행할 작업을 대기 시키는 큐

## 🍀Thread Pool 작동 방식 
1. 쓰레드 생성 
   - 작업이 필요한 만큼 쓰레드를 생성하며, 요청이 계속 들어오면 쓰레드는 `corePoolSize`에서 설정한 사이즈 만큼 생성한다.
2. 요청 처리 
   - 요청이 들어오면 현재 성성되어있는 쓰레드 중 하나가 할당되어 해당 요청을 처리한다. 
   - 요청을 처리한 쓰레드는 다시 `Thread Pool`에 반납된다.
   - 모든 스레드가 작업 중일 경우 `workQueue`에 저장된다.
3. 대기열 사용  
   - `corePoolSize`사이즈 보다 많은 작업이 들어오면, 추가 작업은 `workQueue`에 저장된다.
4. 추가 쓰레드 생성
   - 만약 `workQueue`가 가득 차게 되면, `Thread Pool`은 추가로 쓰레드를 생성하여 최대 `maximumPoolSize`사이즈 만큼 생성합니다.
5. 쓰레드 제거 
   - 작업이 모두 완료되고 더 이상 처리할 작업이 없으면, `corePoolSize`사이즈를 초과하는 쓰레드는 `keepAliveTime`동안 추가 작업을 기다린다.
   - `keepAliveTime`동안 새로운 작업이 들어오지 않으면, 쓰레드는 종료되고 제거됩니다.

<img width="1336" height="700" alt="Image" src="https://github.com/user-attachments/assets/02ea3ac7-23c3-4e60-b3c8-c72fe84b0d0c" />

## 📚Async(비동기) 작업 방식
#### 비동기는 메인 쓰레드(`Tomcat`)에서 실행중인 작업을 `@EnableAsync`로 등록한 `Executor`(쓰레드 풀) 에게 작업을 위임합니다.
1. API 요청이 오면 메인 쓰레드(`Tomcat`)가 로직을 수행합니다.
2. 로직을 수행하다 `@Async`붙은 메서드를 호출 받으면 스프링 AOP 프록시가 동작해서 해당 메서드를 직접 실행하지 않고`TaskExecutor`(쓰레드 풀)에서 생성한 `Thread`에게 실행을 위임합니다.
3. 그러면 `TaskExecutor`(쓰레드 풀)에 설정되어있는 `corePoolSize`에서 쓰레드 하나를 뽑아서 실제 비동기 메서드를 실행합니다.
4. `TaskExecutor`(쓰레드 풀)에서 꺼내 사용한 쓰레드는 종료하지 않고 `TaskExecutor`(쓰레드 풀)에 다시 반납합니다.
5. 이때 메인 쓰레드(`Tomcat`)는 책임을 위임했으니 기다리지 않고 바로 리턴해버립니다.

<img width="1201" height="503" alt="Image" src="https://github.com/user-attachments/assets/d202c149-6f4c-4014-8e9d-e7bd1c631d73" />

## 🔬Spring에 @Async 적용하기 

## 🏉Thread Pool Config 설정하기 
* `Thread Poll`은 여러개 생성이 가능하며 이름을 지정하여 생성합니다. 
* `ThreadPoolTaskExecutor`는 내부적으로 쓰레드 풀 + 작업 큐를 관리합니다. 
```java
@EnableAsync // Spring에서 비동기 처리 @Async를 활성화
@Configuration
public class AppConfig {
    // 빈 설정
    @Bean(name = "defaultTaskExecutor")
    public ThreadPoolTaskExecutor defaultTaskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(150); // corePoolSize 설정
        executor.setMaxPoolSize(200); // maxPoolSize 설정
        executor.setKeepAliveSeconds(10); // keepAliveTime 설정
        executor.setQueueCapacity(100); // queue 최대 크기 설정
        return executor;
    }

    @Bean(name = "messagingTaskExecutor")
    public ThreadPoolTaskExecutor messagingTaskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(200);
        executor.setMaxPoolSize(200); 
        // 최대 Thared가 200이여서 초과하면 queue에 무한으로 쌓인다.
        return executor;
    }
}
```

## 🎮Thread Pool 에서 잘 꺼내 사용하는지 확인
* 비동기 메서드에 반환값이 없으면 `void`를 리턴타입으로 두고 비동기 메서드를 정의하면 됩니다. 
* `asyncCall_1`이라는 메서드를 호출해 각기 다른 `Thread Pool`을 정의하고 어떤 `Thread Pool`이 사용되는지 테스트 해보겠습니다.

```java
@RequiredArgsConstructor
@Service
public class AsyncService {
    private final EmailService emailService;

    public void asyncCall_1() {
        System.out.println("[asyncCall_1] :: " + Thread.currentThread().getName());
        emailService.sendMail();
        emailService.sendMailWithCustomThreadPool();
    }
}
```
* 서로 다른 `Thread Pool`을 사용하는 비동기 메서드를 정의하고 호출하였습니다. 
```java
@Service
public class EmailService {
    @Async("defaultTaskExecutor")
    public void sendMail() {
        System.out.println("[sendMail] :: " + Thread.currentThread().getName());
    }

    @Async("messagingTaskExecutor")
    public void sendMailWithCustomThreadPool() {
        System.out.println("[sendMailWithCustomThreadPool] :: " + Thread.currentThread().getName());
    }
}
```
## 🍸실행 결과
* 실행 결과를 보면, 서로 다른 `Thread Pool`을 사용 해 비동기 메서드가 적절하게 호출되는 것을 확인할 수 있습니다.
* 즉, 작업중이던 메인 `Thread`에서 `Thread Pool`에서 꺼낸 `Thread`에게 위임하는 것을 확인 할 수 있습니다. 

<img width="483" height="88" alt="Image" src="https://github.com/user-attachments/assets/05812667-b09c-4c22-bf26-bda3deb946b7" />

## 🍒@Async 메서드 리턴값을 받아야 할때 
* 비동기는 주로 병렬 처리, 동시에 많은 작업을 처리해야 할 때 없어서는 안되는 기법입니다.
* 비동기 메서드에 반환값이 있으면, `Future`, `ListenableFuture`, `CompletableFuture`타입을 반환 타입으로 사용할 수 있습니다.

## 🍨블로킹(`Blocking`)하여 결과 값 기다리기 
* `f1`, `f2`각각 다른 스레드에서 동시에 실행을 합니다.
* `CompletableFuture.allOf().join()`은 모든 비동기 작업이 끝날 때까지 현재 스레드(`Main Thread`)를 블로킹(대기) 시킵니다.
* 비동기 메서드 작업이 끝나면 `.get()`메서드를 이용해 값을 꺼내 사용할 수 있습니다. 

```java
public String asyncCall_2() throws InterruptedException, ExecutionException {
     // 두 작업을 동시에 실행
     CompletableFuture<String> f1 = asyncyService.firstString();
     CompletableFuture<String> f2 = asyncyService.secondString();

     // 두 future가 끝날 때까지 기다림
     CompletableFuture.allOf(f1, f2).join();

     // 결과 결합
     String result = f1.get() + f2.get();
    
     return result;
 }
```

## 🍍콜백함수(`callback`) 논블로킹(`Non-Blocking`) 방식 사용 
* 콜백함수(`callback`)란 쉽게 말해 비동기 작업이 끝나면 실행할 동작을 미리 등록해 두는 것입니다.
* 콜백을 사용하면 메인 쓰레드(`Main Thread`)가 결과를 기다리지 않고 비동기 작업이 끝나는 즉시 등록해 둔 로직이 실행 되어 비동기 장점을 제대로 살릴 수 있게 됩니다.
* 즉, **콜백 함수는 논블로킹 방식입니다.** 결과가 나올 때까지 멈추지 않고, 다른 작업을 계속 진행하면서 결과가 준비되는 순간 콜백이 호출됩니다.

### 콜백 메서드 정리 
`thenApply` : 결과 값을 받아서 가공할 때 사용합니다.
```java
public CompletableFuture<String> asyncCallWithCallback() throws InterruptedException {
   CompletableFuture<String> f1 = emailService.firstString();

   // f1의 결과를 가공하는 콜백
   return f1.thenApply(result -> {
      return result;
   });
}
```

`thenCompose` : 결과 값을 받아 새로운 비동기 작업을 실행해야 할때 
```java
public CompletableFuture<String> asyncCallWithCallback() throws InterruptedException {
   CompletableFuture<String> f1 = getUserId(); // "user123"

   // userId 받아서 비동기로 회원 조회
   CompletableFuture<String> result =
           f1.thenCompose(userId -> getUserName(userId));
   
   return result;
}
```

`thenAccept` : 결과 값을 받아서 출력하거나 저장 등 후처리만 할 때 사용합니다. <br>
주로 로그 찍기, DB 저장 같은 사이드 이펙트 용도 
```java
public void asyncCallWithCallback() throws InterruptedException {
   CompletableFuture<String> f1 = emailService.firstString();

   // 결과를 받아 로그 찍는 콜백
   f1.thenAccept(result -> {
      System.out.println("리턴 응답 결과: " + result);
   });
}
```
`thenRun` : 결과와 상관없이 끝났을 때 어떤 동작을 실행하고 싶을 때 사용합니다.
```java
public void asyncCallWithCallback() throws InterruptedException {
   CompletableFuture<String> f1 = emailService.firstString();

   // 결과와 상관없이, 끝나면 실행
   f1.thenRun(() -> {
      System.out.println("응답이 잘 넘어 왔어");
   });
}
```
`thenCombine` : 두 개의 비동기 결과를 합쳐서 새로운 결과를 만들 때 사용합니다.
```java
public CompletableFuture<String> asyncCallWithCallback() throws InterruptedException {
   CompletableFuture<String> f1 = emailService.firstString();
   CompletableFuture<String> f2 = emailService.secondString();
   
   // 두 Future가 끝나면 결과를 합쳐서 리턴
   return f1.thenCombine(f2, (r1, r2) -> {
      String result = r1 + r2;
      return result;
   });
}
```

## 🏰블로킹(`Blocking`) Vs 논블로킹(`Non-Blocking`)
### 블로킹(`Blocking`) 단점
* 아래 코드를 보면 2개의 비동기 메서드를 각기 다른 쓰레드가 실행을 해주었으니 이것도 비동기가 아닌가? 라고 생각할 수 있습니다.
* 비동기가 맞지만 2개의 비동기 메서드 결과 값을 기다리는 동안 메인 쓰레드(`Main Thread`)는 계속 대기하고 있습니다.
* 즉, 결과가 준비될 때까지 메인 쓰레드(`Main Thread`)는 아무 일도 하지 못하고 멈춰 있다는 단점이 있습니다.
* 비동기 작업의 진짜 장점은 **_"작업이 다 끝날 때까지 기다리지 않고, 끝나는 즉시 바로 원하는 동작을 실행"_** 할 수 있어야 합니다.

```java
public String asyncCall_2() throws InterruptedException, ExecutionException {
     CompletableFuture<String> f1 = asyncyService.firstString();
     CompletableFuture<String> f2 = asyncyService.secondString();

     CompletableFuture.allOf(f1, f2).join();
     String result = f1.get() + f2.get();
     
     // 블로킹이 끝나야 아래 코드 진행 가능 
     System.out.println("여기서 다른 로직 계속 처리 가능");
     return result;
 }
```
### 논블로킹(`Non-Blocking`) 장점 
* 아래 코드로 예시를 들면 비동기 값인 `f1`값과 `f2`값을 반환 받으면 콜백 함수를 통해 결과 값을 저장합니다.
* 이때 콜백 함수를 사용하여 논블로킹(`Non-Blocking`) 상태로 메인 쓰레드(`Main Thread`)가 기다리지 않고 바로 다음 코드를 실행합니다.
* 블로킹(`Blocking`) 상태였을 때는 메인 쓰레드(`Main Thread`)가 결과값이 나올 때 까지 기다렸다가 다음 코드를 실행하였지만 
* 논블로킹(`Non-Blocking`)을 사용하여 좀 더 비동기적인 코드를 작성할 수 있습니다.
````java
public void asyncCallWithCallback(String code) throws InterruptedException {
   CompletableFuture<String> f1 = emailService.firstString();
   CompletableFuture<String> f2 = emailService.secondString();
   
   CompletableFuture<String> mailCombined = f1.thenCombine(f2, (r1, r2) -> r1 + r2);
   
   mailCombined.thenAccept(result -> {
      numberRepository().save(result);
   });

   // 메인 스레드는 바로 아래 코드 실행 가능
   System.out.println("여기서 다른 로직 계속 처리 가능");
}
````

<img width="1751" height="773" alt="Image" src="https://github.com/user-attachments/assets/b8d29f9c-cdba-4f21-8f2b-f5b0060e26af" />





 


