# 📚 Spring - Async 비동기 처리 알아보기
> 💡 비동기 메서드를 사용하면 서버의 성능을 향상하고 응답 시간을 줄일 수 있습니다.

## Thread Pool 이란? 
* `Thread Pool`이란 미리 일정한 수의 `Thread`를 미리 생성해서 준비해두는 메커니즘입니다.
* `Thread`생성 비용은 비싸기 때문에 미리 필요한 만큼 `Thread`를 `Pool`에 생성해 놓고, 필요할 때 꺼내서 사용합니다.
* `Thread Pool`을 적용하면, `Thread`생성 비용을 줄일 수 있다. 
* 또한 과도한 `Thread`생성을 방지할 수 있어 시스템 과부하 상태를 방지할 수 있다. 

## Thread Pool 구성 요소 
* `corePoolSize` : `Thread Pool`이 유지하는 기본 스레드 수
* `maximumPoolSize` : `Thread Pool`에서 생성 가능한 최대 스레드 수
* `keepAliveTime` : `corePoolSize`를 초과하는 스레드가 사용되지 않고 유지될 수 있는 시간
* `workQueue` : 실행할 작업을 대기 시키는 큐

## Thread Pool 작동 방식 
1. 쓰레드 생성 
   - 작업이 필요한 만큼 쓰레드를 생성하며, 요청이 계속 들어오면 쓰레드는 `corePoolSize`에서 설정한 사이즈 만큼 생성한다.
2. 요청 처리 
   - 요청이 들어오면 현재 성성되어있는 쓰레드 중 하나가 할당되어 해당 요청을 처리한다. 
   - 요청을 처리한 쓰레드는 다시 `Thread Pool`에 반납된다.
   - 모든 스레드가 작업 중일 경우 `workQueue`에 저장된다.
3. 대기열 사용  
   - `corePoolSize`사이즈 보다 많은 작업이 들어오면, 추가 작업은 `workQueue`에 저장된다.
4. 추가 쓰레드 생성
   - 만약 `workQueue`가 가득 차게 되면, `Thread Pool`은 추가로 쓰레드를 생성하여 최대 `maximumPoolSize`사이즈 만큼 생성합니다.
5. 쓰레드 제거 
   - 작업이 모두 완료되고 더 이상 처리할 작업이 없으면, `corePoolSize`사이즈를 초과하는 쓰레드는 `keepAliveTime`동안 추가 작업을 기다린다.
   - `keepAliveTime`동안 새로운 작업이 들어오지 않으면, 쓰레드는 종료되고 제거됩니다.

<img width="1336" height="700" alt="Image" src="https://github.com/user-attachments/assets/02ea3ac7-23c3-4e60-b3c8-c72fe84b0d0c" />

## Async(비동기) 작업 방식
#### 비동기는 메인 쓰레드(`Tomcat`)에서 실행중인 작업을 `@EnableAsync`로 등록한 `Executor`(쓰레드 풀) 에게 작업을 위임합니다.
1. API 요청이 오면 메인 쓰레드(`Tomcat`)가 로직을 수행합니다.
2. 로직을 수행하다 `@Async`붙은 메서드를 호출 받으면 스프링 AOP 프록시가 동작해서 해당 메서드를 직접 실행하지 않고`TaskExecutor`(쓰레드 풀)에서 생성한 `Thread`에게 실행을 위임합니다.
3. 그러면 `TaskExecutor`(쓰레드 풀)에 설정되어있는 `corePoolSize`에서 쓰레드 하나를 뽑아서 실제 비동기 메서드를 실행합니다.
4. `TaskExecutor`(쓰레드 풀)에서 꺼내 사용한 쓰레드는 종료하지 않고 `TaskExecutor`(쓰레드 풀)에 다시 반납합니다.
5. 이때 메인 쓰레드(`Tomcat`)는 책임을 위임했으니 기다리지 않고 바로 리턴해버립니다.

<img width="1201" height="503" alt="Image" src="https://github.com/user-attachments/assets/d202c149-6f4c-4014-8e9d-e7bd1c631d73" />

## Spring에 @Async 적용하기 

### Thread Pool Config 설정하기 
* `Thread Poll`은 여러개 생성이 가능하며 이름을 지정하여 생성합니다. 
* `ThreadPoolTaskExecutor`는 내부적으로 쓰레드 풀 + 작업 큐를 관리합니다. 
```java
@EnableAsync // Spring에서 비동기 처리 @Async를 활성화
@Configuration
public class AppConfig {
    // 빈 설정
    @Bean(name = "defaultTaskExecutor")
    public ThreadPoolTaskExecutor defaultTaskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(150); // corePoolSize 설정
        executor.setMaxPoolSize(200); // maxPoolSize 설정
        executor.setKeepAliveSeconds(10); // keepAliveTime 설정
        executor.setQueueCapacity(100); // queue 최대 크기 설정
        return executor;
    }

    @Bean(name = "messagingTaskExecutor")
    public ThreadPoolTaskExecutor messagingTaskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(200);
        executor.setMaxPoolSize(200); 
        // 최대 Thared가 200이여서 초과하면 queue에 무한으로 쌓인다.
        return executor;
    }
}
```

## Thared Pool 에서 잘 꺼내 사용하는지 확인
* 비동기 메서드에 반환값이 없으면 `void`를 리턴타입으로 두고 비동기 메서드를 정의하면 됩니다. 
* `asyncCall_1`이라는 메서드를 호출해 각기 다른 `Thared Pool`을 정의하고 어떤 `Thared Pool`이 사용되는지 테스트 해보겠습니다.

```java
@RequiredArgsConstructor
@Service
public class AsyncService {
    private final EmailService emailService;

    public void asyncCall_1() {
        System.out.println("[asyncCall_1] :: " + Thread.currentThread().getName());
        emailService.sendMail();
        emailService.sendMailWithCustomThreadPool();
    }
}
```
* 서로 다른 `Thared Pool`을 사용하는 비동기 메서드를 정의하고 호출하였습니다. 
```java
@Service
public class EmailService {
    @Async("defaultTaskExecutor")
    public void sendMail() {
        System.out.println("[sendMail] :: " + Thread.currentThread().getName());
    }

    @Async("messagingTaskExecutor")
    public void sendMailWithCustomThreadPool() {
        System.out.println("[sendMailWithCustomThreadPool] :: " + Thread.currentThread().getName());
    }
}
```
## 실행 결과
* 실행 결과를 보면, 서로 다른 `Thread Pool`을 사용 해 비동기 메서드가 적절하게 호출되는 것을 확인할 수 있습니다.
* 즉, 작업중이던 메인 `Thread`에서 `Thread Pool`에서 꺼낸 `Thread`에게 위임하는 것을 확인 할 수 있습니다. 

<img width="483" height="88" alt="Image" src="https://github.com/user-attachments/assets/05812667-b09c-4c22-bf26-bda3deb946b7" />

## @Async 메서드 리턴값을 받아야 할때 
* 비동기는 주로 병렬 처리, 동시에 많은 작업을 처리해야 할 때 없어서는 안되는 기법입니다.
* 동적으로 처리할때는 응답 값을 리턴 받을 때 까지 기다렸지만,

