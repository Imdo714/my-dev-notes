# 📚 Spring - Java 메모리 영역 구조 알아가기 

> 💡 memory leak같은 현상을 피하기 위해서는 메모리 구조에대해서 알고 빨리 원인을 찾아야 합니다.

## JVM 란?
* JVM(`Java Virtual Machine`)은 자바를 실행하기 위한 가상 기계, 자바와 운영체제 사이에서 중개자 역할을 수행하며 
* 자바가 운영체제에 구애 받지 않고 프로그램을 실행할 수 있도록 도와줍니다. 
* 즉, 자바 코드를 실행하려면 그냥 OS가 실행하는게 아니라 JVM이 해석하고 관리해 줍니다.
* 또한 메모리 힙에 올라온 불필요한 값들을 가바지 컬렉터로 불필요한 메모리 정리까지 JVM이 대신 해줍니다.

## JVM 컴파일 과정
* 우리가 작성한 Java코드는 기계가 이해할 수 없어 읽을 수 있도록 기계어로 컴파일 해주는 과정이 필요 합니다.
* Java는 다른 언어와 달리 기계어로 바로 컴파일 되는게 아니라, JVM이라는 가상머신을 거친 후 OS로 전달하는 구조를 가져
* Java코드를 컴파일시 JVM이 읽을 수 있는 `bytecode`(`.class`)로 변환 후 다시 JVM이 `bytecode`를 `Interpreter`와 `JIT`컴파일러를 이용해 기계어로 변환합니다.

<img width="957" height="418" alt="Image" src="https://github.com/user-attachments/assets/54504a25-2b49-4e33-831b-0ae927cdcfb6" />

* 인터프리터 (`Interpreter`) : 바이트 코드 명령어를 하나씩 읽어서 해석하고 바로 실행 
* `JIT` 컴파일러 : 자주 실행되는 부분을 기계어 코드로 변환 후 캐싱하여 재사용합니다.

## JVM 메모리 구조 
* 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재 하는 곳을 **"런타입 데이터 영역"** 이라고 합니다.
* 런타입 데이터 영역은 여러 종류가 있지만, 핵심적으로 이해해야 할 부분은 `Method`, `Heap`, `Stack`영역입니다.
* 이때 `Method`, `Heap`은 모든 쓰레드(`Thread`)가 공유하는 영역이며 `Stack`은 각 쓰레드(`Thread`) 마다 생성되는 개별 영역입니다.

## Method(Static) 영역 
* `Method`영역은 클래스를 구성하는 (`클래스 정보`, `static 변수`, `상수`, `메서드 코드`) 정보들이 저장되는 영역입니다. 
* JVM이 동작해서 클래스가 로딩될 때 생성되며 프로그램이 시작될 때부터 종료될 때까지 메모리에 남아있습니다.

## Heap 영역 
* `Heap`영역은 동적으로 할당된 메모리 영역이며, `Method`와 함께 모든 쓰레드가 공유합니다.
* `Heap`영역에는 new 연산자로 생성되는 클래스와 인스턴스 변수, 배열 타입 등 `Reference Type`이 저장됩니다. 
* 힙의 특징으로는 동적으로 메모리가 할당되고 해제됩니다. 이때 더이상 사용되지 않는 객체는 가바지 컬렉터에 의해 자동으로 메모리에서 제거됩니다.

## Stack 영역 
* `Stack`영역에는 함수 관련 데이터 (`지역변수`, `매개변수`, `리턴 값`, `메서드 실행 단위`)등이 저장됩니다.
* 메서드가 정의하는 기본 자료형에 해당되는 지역변수의 데이터 값이 저장됩니다.
* 메서드가 호출될 때 메모리에 할당되고 종료되면 메모리에서 제거됩니다.
* 스택은 마지막에 들어온 값이 먼저 나가는 후입선출(`LIFO`) 구조로 되어있습니다.

## 예제 코드
```java
class Employee {
    String name;
    Integer salary;
    Integer sales;
    Integer bonus;

    public Employee(String name, Integer salary, Integer sales) {
        this.name = name;
        this.salary = salary;
        this.sales = sales;
    }
}

public class MemoryExample {
    static int BONUS_PERCENTAGE = 10;

    static int getBonusPercentage(int salary) {
        int percentage = salary * BONUS_PERCENTAGE / 100;
        return percentage;
    }

    static int findEmployeeBonus(int salary, int noOfSales) {
        int bonusPercentage = getBonusPercentage(salary);
        int bonus = bonusPercentage * noOfSales;
        return bonus;
    }

    public static void main(String[] args) {
        Employee Lim = new Employee("Lim", 5000, 5);
        john.bonus = findEmployeeBonus(john.salary, john.sales);
        System.out.println(john.bonus);
    }
}
```

## 객체 생성하기 
* `new Employee("Lim", 5000, 5);`로 객체를 생성해 `Lim`이라는 변수명에 담습니다.
* 변수명은 `Stack`에 쌓이고 `Heap`에는 객체 주소의 값과 `Reference Type`이 저장됩니다.
* 모든 함수 호출은 스레드의 스택 메모리에 프레임 블록으로 추가됩니다. 

<img width="1539" height="753" alt="Image" src="https://github.com/user-attachments/assets/b356e99e-85fd-46dd-a7a1-fe080f93ae2e" />

## `findEmployeeBonus()`함수 호출 시
* `findEmployeeBonus`함수를 호출시 `Stack`에는 함수 와 매개변수가 저장이됩니다. 
* 이때 매개변수는 원시타입 이기 때문에 변수명과 값을 `Stack`에 저장합니다. 

<img width="1526" height="772" alt="Image" src="https://github.com/user-attachments/assets/64d083f4-dc16-400b-8c32-ddb755adefcb" />

## `getBonusPercentage()` 함수 호출 시 
* `getBonusPercentage`함수를 호출하면 함수와 매겨변수는 `Stack`에 저장되고 
* `percentage`변수명에 계산한 값을 저장하고 리턴합니다. 
* 이때 함수가 반환되면 `Stack`은 후입선출 구조로 나중에 들어온 함수가 먼저 삭제되고 그 아래 함수로 돌아갑니다.

<img width="1564" height="869" alt="Image" src="https://github.com/user-attachments/assets/abd7d442-3a84-428d-b1e6-e87877e60450" />

## 함수 반환 시 
* `getBonusPercentage`함수에서 받은 반환 값과 매개변수 `noOfSales`값을 계산한 값을 
* `bonus`변수명에 담고 반환합니다. 
* `getBonusPercentage`함수도 반환 후 스택 프래임에서 삭제가 됩니다. 

<img width="1549" height="711" alt="Image" src="https://github.com/user-attachments/assets/20baa7bd-419e-454e-8556-88be99eca2b7" />

## 최종 
* `Employe.bonus`는 `Integer`는 `Reference Type`이기에 `Heap`에 저장되없습니다.
 
<img width="1572" height="657" alt="Image" src="https://github.com/user-attachments/assets/27612363-cea8-458b-9768-f9f06d44b8b0" />


