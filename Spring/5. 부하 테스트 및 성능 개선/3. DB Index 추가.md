# 📚 Spring - Index 추가 해 조회 성능 향상 시키기 

> 💡 Index는 검색 속도 향상을 높여주는 약이지만, 데이터 변경에는 독이다.

## 💛Index(인덱스)란?
* 인덱스는 테이블의 동작속도(조회)를 높여주는 자료구조이다. 인덱스로 데이터의 위치를 빠르게 찾아주는 역할이며 
* 인덱스가 설정되지 않았다면 `Table Full Scan`이 일어나 성능이 저하되거나 치명적인 장애가 발생 합니다.
* 인덱스는 조회속도는 빨라지지만 `UPDATE`, `INSERT`, `DELETE`의 속도는 저하된다는 단점이 있어 꼭 필요한 컬럼에 인덱스를 생성해야 합니다.
* 인덱스가 설정된 컬럼은 따로 복사가 되어 페이징 정렬을 해야 해서 10% 정도 공간을 차지 합니다.

## 💜Index(인덱스) 특징 
### 장점 
* 적절한 인덱스를 생성하고 사용하면 조회 성능을 획기적으로 개선할 수 있음
* 검색 속도 향상 & 시스템 성능 향상
### 단점
* 인덱스는 대략 테이블 크기의 10% 공간이 추가로 필요 (인덱스 페이지 때문)
* 데이터의 변경 작업 (`INSERT`, `UPDATE`, `DELETE`)이 자주 일어나면 오히려 성능에 악영향 (페이지 정렬 작업 때문)

## 💙Index(인덱스) 동작 원리
> Index(인덱스) 사용하기 전에는 11데이터를 찾을 때 1부터 13까지 앞에서 부터 차례대로 `Full Scan`을 하기 때문에 속도가 저하되었습니다.
### B-Tree
* Index(인덱스)는 B-Tree 자료 구조로 각 노드가 여러개의 자식을 가질 수 있는 구조입니다.
* 아래 이미지 처럼 노드 내의 키들은 정렬된 상태를 유지하고, 키 사이에는 포인터가 있어서 자식 노드를 가리킵니다.
* Index 추가하고 나서 부터는 정렬된 상태에서 데이터8을 물어 봤을 때 11이 8보다 크니깐 8밑으로 정렬된 애들은 읽지도 않아서 빠르게 찾아줍니다. 

<img width="1047" height="658" alt="Image" src="https://github.com/user-attachments/assets/80aa0bce-b224-4d32-9bf9-98f52db65822" />

### B+Tree
* `B+Tree`는 `B-Tree`의 확장 개념으로 똑같은 개념으로 짤라먹기 식으로 데이터를 찾습니다.
* 다른 점은 맨 아래 노드끼리 화살표가 연결되어 있는데 장점은 이동이 매우 쉬워집니다.
* 예를 들어 데이터 6~8 범위 찾아줘 했을 때 `B-Tree`는 6을 찾고 다시 첫번째 노드에서 7이상이니 오른쪽으로 갔는데 
* `B+Tree`는 6을 찾고 연결된 화살표를 통해 7, 8데이터를 찾습니다. 
* 즉, 범위 검색에 매우 강점을 가지고있습니다. 

<img width="1174" height="678" alt="Image" src="https://github.com/user-attachments/assets/34254135-3a0e-424c-ab99-7c11bd1e914b" />

## 🐈Index(인덱스) 문법 
* 일반 Index(인덱스) 생성 방법 
* 증복 값 허용
```mysql
CREATE INDEX 인덱스이름 ON 테이블이름(필드이름1)
```
* 유니크 Index(인덱스) 생성 방법
* 중복 값 방지
```mysql
CREATE UNIQUE INDEX 인덱스이름 ON 테이블이름(필드이름1)
```
* Index(인덱스) 조회
```mysql
SHOW INDEX FROM 테이블이름
```
* Index(인덱스) 삭제
```mysql
ALTER TABLE 테이블이름 DROP INDEX 인덱스이름;
```

## 🍁Index(인덱스) 적용 전 Latency 측정 결과
* 간단하게 요청 받은 `Study Code`가 DB에 있으면 Study 정보를 응답해주는 코드입니다.
```java
public StudyResponse selectStudyCode(String code) {
    Study study = generatorIdRepository.getStudyByCode(code)
            .orElseThrow(() -> new IllegalArgumentException("아무것도 없는 디?"));
    return new StudyResponse(study.getCode(), study.getName());
}
```

* 1분에 1초에 10번씩 요청 보내다가 점점 30번까지 요청을 보내 보겠습니다.
```yaml
config:
  target: "http://localhost:8080"
  phases:
    - duration: 60
      arrivalRate: 10
      rampTo: 30
  payload:
    path: "studyCode.csv"
    fields:
      - "code"
scenarios:
  - name: "select code"
    flow:
      - get:
          url: "/study/code?code={{ code }}" # RequestParam 사용
```

**🚨결과는 로컬에서 진행 하였기 때문에 네트워크 지연, 데이터베이스 지연 등이 없어서 빠르게 나왔습니다.🚨**
* mean 평균 속도가 `5ms`이고 p95가 `8ms` p99가 `15ms`가 나왔습니다.

<img width="704" height="162" alt="Image" src="https://github.com/user-attachments/assets/7774f430-c9ad-4949-b400-7fe896901537" />

## 🌿Index(인덱스) 적용 후 Latency 측정 결과
* `code` 컬럼은 증복이 되지 않는 컬럼이여서 `UNIQUE INDEX`로 생성하였습니다. 
```mysql
CREATE UNIQUE INDEX idx_unique_study_code ON study(code);
```

**🚨결과는 로컬에서 진행 하였기 때문에 네트워크 지연, 데이터베이스 지연 등이 없어서 빠르게 나왔습니다.🚨**
* 똑같이 1분에 1초에 10번씩 요청 보내다가 점점 30번까지 요청을 보내 보겠습니다.
* mean 평균 속도가 `2ms`이고 p95가 `3ms` p99가 `4ms`가 나왔습니다.
> Index(인덱스)를 적용한 이후, 기존 대비 응답 시간이 크게 단축되었음을 확인할 수 있었습니다.

<img width="699" height="166" alt="Image" src="https://github.com/user-attachments/assets/1015b0e0-1394-4e96-ba2d-bbfb543a2ae4" />