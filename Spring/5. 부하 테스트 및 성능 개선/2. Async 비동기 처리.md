# 📚 Spring - Async 비동기 처리로 Latency 줄이기

> 💡 비동기 메서드를 사용하면 서버의 성능을 향상하고 응답 시간을 줄일 수 있습니다. 

## 😴Async(비동기)란?
* 작업을 요청한 후 결과가 끝날 때까지 기다리지 않고, 다른 작업을 이어서 할 수 있는 방식입니다. 
### 동기 VS 비동기 
* 동기(`Sync`) : A작업이 끝나야 B작업을 실행 할 수 있음
  * A (3초 걸림) → B (2초 걸림) → 총 5초
* 비동기(`Async`) : A작업을 요청해두고 기다리지 않고 바로 B작업을 실행 함
  * A (3초) + B (2초) 동시에 진행 → 총 3초

## 😎Async(비동기)는 언제 사용할까?
* 사용자 경험, 사용자가 즉시 결과를 필요로 하지 않는 작업이나, 응답 시간을 단축시키기 위해 백그라운드로 처리해도 되는 작업
* I/O 작업이 많을때, CPU는 놀고 있는데 응답 기다리느라 시간이 길어질 때
* 병렬 처리, 동시에 많은 요청을 효율적으로 처리해야 할 때
* 요청, 응답, 지연시간을 줄이고 더 많은 동시 접속을 처리하고 싶을 때

## 😂Async(비동기) 사용할때 고민해야 할 부분
Study 정보 저장을 Async(비동기) 방식으로 사용할 때는 해당 로직의 핵심 여부를 판단해야 합니다.
* 핵심 로직은 동기(`Sync`)적으로 처리하여 정확성과 신뢰성을 보장합니다.
* 핵심적인 로직은 비동기(`Async`)적으로 처리할 때 신중하게 고려해야합니다.

즉각적인 데이터 일관성이 필요하지 않고, 일정 시간의 지연이 허용되는 경우 비동기(`Async`)로 처리합니다.
* 결제 시스테이라면 결제 요청에 대해 "요청 접수 완료"만 빨리 주고
* 실제 영수증 발송, 포인트 적립 같은 건 백그라운드에서 진행

작업 실패시 시스템이나 사용자에게 미치는 영향이 안크다면 비동기(`Async`)로 처리합니다. 실패 시 에는?
* 비동기(`Async`)적으로 처리 했는데 실패 했을 시 실패 로그를 기록합니다.
* 작업이 실패하면 일정 횟수나 조건에 따라 자동으로 재시도하도록 설계합니다.
* 메시지 큐 사용하여 작업을 메시지 큐에 넣어 안정적인 전달과 처리를 보장하며, 큐 시스템 자체의 재시도 및 장애 처리 기능을 활용합니다.


## ❓요구 사항
### 스터디 그룹 생성 API를 요청 하면 서버에서 생성한 Study Code를 생성해 리턴해주세요. 

* 클라이언트에서 스터디 생성 API를 요청하면  `getString()`메서드를 통해 코드를 받아
* `do while`문을 통해 DB에 이미 있는 Study Code인지 조회를 하고 DB애 없으면 생성된 코드를 리턴하여
* 생성한 스터디 정보들을 DB에 저장합니다. 
```java
@Transactional
public StudyCodeResponse createStudy(CreateStudyDTO createStudyDTO) {
    String code = getString();

    Study study = new Study(code, createStudyDTO.getName());
    generatorIdRepository.saveStudy(study);

    return new StudyCodeResponse(code);
}

private String getString() {
    String code;
    do {
        code = GeneratorUUID.generateRandomStudyCode();
    } while (existsByCode(code));

    return code;
}

public boolean existsByCode(String code) {
    return generatorIdRepository.existsByCode(code);
}
```
* Study Code를 생성해주는 Util클래스를 생성해 0부터 z까지 6개의 랜덤 문자를 조합하여 리턴 합니다.
```java
public class GeneratorUUID {

    private static final Random RANDOM = new Random();
    private static final String[] password = {
            "0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
            "A", "B", "C", "D", "E", "F", "G", "H", "I", "J",
            "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T",
            "U", "V", "W", "X", "Y", "Z"
    };

    public static String generateRandomStudyCode() {
        StringBuilder userIdBuilder = new StringBuilder();
        for (int i = 0; i < 6; i++) {
            int index = RANDOM.nextInt(password.length);
            userIdBuilder.append(password[index]);
        }
        return userIdBuilder.toString();
    }
}
```

```java
public class GeneratorIdRepositoryImpl implements GeneratorIdRepository {
    private final StudyRepository studyRepository;

    @Override
    public void saveStudy(Study study) {
        studyRepository.save(study);
    }

    @Override
    public boolean existsByCode(String code) {
        return studyRepository.existsByCode(code);
    }
}
```

## 💩Study 생성 API가 하는 일 
### 1. `Study Code`생성
### 2. DB에 존재하는지 체크 
### 3. 생성된 `Study Code` DB에 저장 

<img width="1150" height="433" alt="Image" src="https://github.com/user-attachments/assets/9eaf5c67-b910-46f8-9fa9-966908d7ef6d" />

## 💻Latency 측정하기 
* 1분 동안 1초에 10번씩 Study생성 요청을 보내다가 점점 1초에 30번씩 요청을 보내는 시나리오를 작성하였습니다. 
* 그러면 1분 에 총 1,200번의 Study생성 요청을 보냅니다.
```yaml
config:
  target: "http://localhost:8080"
  phases:
    - duration: 60
      arrivalRate: 10 # 60초 당안 1초에 10번씩 요청 보내다가 점점 30까지 요청을 보냄
      rampTo: 30
  payload:
    path: "studyName.csv"
    fields:
      - "name"
scenarios:
  - name: "Create StudyCode"
    flow:
      - post:
          url: "/study/code"
          json:
            originalUrl: "{{ name }}"
```

**🚨결과는 로컬에서 진행 하였기 때문에 네트워크 지연, 데이터베이스 지연 등이 없어서 빠르게 나왔습니다.🚨**
* mean 평균 속도가 `10ms`이고 p95가 `13ms` p99가 `27ms`가 나왔습니다.

<img width="710" height="165" alt="Image" src="https://github.com/user-attachments/assets/5d6624cc-ee10-4aea-9287-cdabe0fc3376" />

## 🐋성능 개선 방법 고민해보기 
> 현제 코드를 보면 API요청이 오면 서버에서 Study Code를 생성하고 DB에 중복 검사를 하고 Study 정보를 저장합니다.

* `Latency`를 단축하기 위해서 요구사항을 보면 Study 생성 API요청을 보내면 서버에서 생성한 `Study Code`만 응답 해주면 됩니다. 
* 클라이언트가 굳이 생성한 `Study Code`를 저장할 때까지 기다릴 필요는 없기 때문입니다.

<img width="1256" height="525" alt="Image" src="https://github.com/user-attachments/assets/0be89903-06a8-4209-960f-c6ed8de9e8f8" />

### 그러면 Study Code를 생성하고 DB에 어떻게 증복 검사하고 저장은 어떻게 할껀데 ??
* 현제 `Study Code`는 0~Z까지 6개를 랜덤으로 뽑아 DB에 증복 검사를 합니다. 
* 그냥 처음부터 증복이 되지 않게 `Snowflake`알고리즘 분산 ID 생성 방식을 사용하여 증복되지 않게 만들면 됩니다.
* Study 정보 저장은 Async(비동기) 방식을 사용해 처리하면 됩니다. 

## 🍂Async(비동기) 적용하기 
* 이전에는 랜덤으로 `Study Code`를 생성하여 DB에 증복되어있는 지 `do while`문으로 검사 하는 방식을 사용하여 
* 계속 DB에 저장되어있는 `Study Code`가 나온다면 지연시간이 더 증가하였을 겁니다. 
* `asyncSaveStudy`메서드를 Async(비동기)방식을 적용시켜 Study 정보를 저장할때 까지 기다리지 않고 바로 `Study Code`를 응답 할 수 있게 성능 개선하였습니다. 
```java
@Transactional
public StudyCodeResponse createStudy(CreateStudyDTO createStudyDTO) {
    String code = GeneratorUUID.generateRandomStudyCode();

    Study study = new Study(code, createStudyDTO.getName());
    generatorIdRepository.asyncSaveStudy(study);

    return new StudyCodeResponse(code);
}
```
* `Study Code`생성 부분을 DB에서 검사하지 않고 고유한 값으로 만들기 위해 `Snowflake`알고리즘 방식을 사용할려고 했지만
* 저희 서비스는 작기 떄문에 요청 날짜 + 시간 + UUID 를 더해서 문자 값을 생성 해주었습니다. 
* 같은 시간에 요청을 해도 UUID를 더하기 때문에 증복이 되지 않습니다. 
```java
public class GeneratorUUID {
    private static final Random RANDOM = new Random();
    private static final String ALPHANUM = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";

    public static String generateRandomStudyCode() {
        // 현재 시간 (yyyyMMddHHmmss)
        String timePart = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyMMddHHmmss"));
        // 랜덤 3자리
        StringBuilder randPart = new StringBuilder();
        for (int i = 0; i < 3; i++) {
            randPart.append(ALPHANUM.charAt(RANDOM.nextInt(ALPHANUM.length())));
        }
        return timePart + randPart; // 예: 250819123045A7F
    }
}
```
* `@Async`어노테이션은 메서드를 "비동기 메서드"로 실행하도록 지정하는 어노테이션입니다.
* 실제 작업은 별도의 스레드에서 비동기적으로 수행이 됩니다.
* 해당 어노테이션이 지정된 메서드는 반드시 접근 제한자로 `public`을 선언해야 합니다. 이는 메서드가 `public`이어야 프록시 될 수 있기 때문입니다.
```java
public class GeneratorIdRepositoryImpl implements GeneratorIdRepository {

    private final StudyRepository studyRepository;

    public GeneratorIdRepositoryImpl(StudyRepository studyRepository) {
        this.studyRepository = studyRepository;
    }

    @Async
    @Override
    public void asyncSaveStudy(Study study) {
        studyRepository.save(study);
    }
}
```

## 🌱Async(비동기) 적용 후 Study 생성 API가 하는 일
### 1. `Snowflake`알고리즘 방식으로 `Study Code`생성
### 2. 생성된 S`tudy Code` 비동기(`Async`)방식으로 DB에 저장
### 3. 생성된 `Study Code` 클라이언트 한테 바로 응답

<img width="1147" height="371" alt="Image" src="https://github.com/user-attachments/assets/8e75e945-1731-487a-8bc4-cabf83af0d26" />


## 🎉Async(비동기) 적용 후 Latency 측정하기 
**🚨결과는 로컬에서 진행 하였기 때문에 네트워크 지연, 데이터베이스 지연 등이 없어서 빠르게 나왔습니다.🚨**
* 이전 시나리오와 똑같이 1분 동안 1초에 10번씩 Study생성 요청을 보내다가 점점 1초에 30번씩 요청을 보내는 시나리오를 작성하였습니다. 
* mean 평균 속도가 `1ms`이고 p95가 `3ms` p99가 `4ms`가 나왔습니다. 
* Async(비동기) 방식을 적용한 이후, 기존 대비 응답 시간이 크게 단축되었음을 확인할 수 있었습니다.

<img width="701" height="161" alt="Image" src="https://github.com/user-attachments/assets/a857ee0f-9428-4868-a836-b45388d68c89" />


