# 📚 Spring - Caffeine Cache 처리로 Latency 줄이기

> 💡 Caffeine Cache 로 불필요한 DB 반복 작업을 하지 않고 빠르게 캐시에서 꺼내 응답 시간을 줄일수 있습니다.

## 🌊Cache(캐싱) 이란?
* 자주 사용되는 데이터를 메모리에 저장하여 빠른 검색을 가능하게 하는 기능을 제공합니다. 
* API의 호출에 따라서 캐시를 이용하여 서버의 부하를 줄이고 API 성능을 최적화 하여 응답시간을 단축 시키는 역할을 수행합니다.
* 캐싱된 데이터가 있으면 메서드 실행없이 데이터를 반환하고 없으면 DB 에서 조회한 다음 메서드 반환 값을 메모리에 캐시한다.
* 캐싱은 value 와 Key 를 같이 사용하여 캐시의 키 값으로 사용합니다.

## 🐹Cache(캐싱) 사용 목적 
* DB 로부터 데이터를 조회하는 경우 동일한 데이터를 반복하여 조회 함으로써 불필요한 일을 반복하는 문제가 발생할 때 사용
* 처음 데이터를 DB에서 조회하고 캐시에 저장한 후 똑같은 API 요청이 오면 캐시에 저장되어있는 데이터를 조회함으로 써
* 데이터베이스 지연 시간, 네트워크 지연시간이 단축되어 응답 시간을 단축 하며 DB 쿼리 비용도 절약합니다.

<img width="925" height="446" alt="Image" src="https://github.com/user-attachments/assets/c69a6e57-6faa-4986-b41b-f50488342ce4" />

## 🌳Cache(캐싱) 사용시 고려 사항
* 캐싱 대상을 선정할 때는 읽기 비중이 높고, 변경이 자주 일어나지 않는 데이터를 캐싱하는게 적합합니다.
  * 데이터 변경이 자주 일어나면 캐시 데이터와 DB 데이터가 다를 수 있어 일관성 보장이 안된다.
  * 데이터를 변경하게 되면 `CacheEvict`를 이용해 캐시를 삭제해주어야 한다.
* 캐시를 무효화를 하지 않으면 메모리가 낭비 되어 꼭 `TTL`설정을 해주어야 합니다.
* 캐시가 비었을 때(DB로 가는 경우) 성능이 급격히 떨어질 수 있습니다. 이것을 캐시 미스라고 합니다.
  * DB에서 조회한 데이터를 캐시에 저정해야 해서 시간이 조금 걸림

## 🍂로컬 캐시 Vs 글로벌 캐시 

### 로컬 캐시 
로컬 캐싱은 서버 내부 저장소에 캐시 데이터를 저장하는 것이다. 따라서 속도는 빠르지만 서버간의 데이터 공유가 안된다는 단점이 존재한다. 
즉 일관성 문제가 발생할 수 있고 서버별 중복된 캐시 데이터로 인한 서버 자원 낭비, 힙 영역에 저장된 데이터로 발생하는 GC에 대한 문제 등을 고려해야한다.

### 글로벌 캐시 
글로벌 캐싱은 서버 내부 저장소가 아닌 별도의 캐시 서버를 두어 서버에서 캐시 서버를 참조하는 것이다. 
캐시 데이터를 얻으려 할 때 마다 네트워크 트래픽이 발생하기 때문에 로컬 캐싱보다 속도는 느리지만, 서버간 데이터를 쉽게 공유할 수 있기 때문에 로컬 캐싱의 정합성 문제와 중복된 캐시 데이터로 인한 서버 자원 낭비 등의 문제점을 해결할 수 있다.

## 🌿Spring Caffeine Cache 사용 
* `Caffeine`은 Java 진영에서 가장 많이 쓰이는 인메모리 캐시 라이브러리 중 하나이며 
* 다양한 만료 정책, Spring과 좋은 통합성을 가지며 단일 서버에서는 빠르고 효율적인 캐싱이라 생각해서 선택하였습니다.

## ⛅Caffeine 디펜더시 추가 
```java
implementation 'com.github.ben-manes.caffeine:caffeine:3.1.1'
```
## 🎋여러 종류 캐싱할수 있도록 Enum Type 생성 
* `cacheName` : 캐시를 적용할 이름
* `expiredAfterWrite` : 캐시 만료 시간 설정 
* `maximumSize` : 캐시에 적용되는 엔티티의 수를 제한 
```java
@Getter
public enum CacheType {

   PROGRAMS("codeCache", 1 * 60 * 24, 50);

   CacheType(String cacheName, int expiredAfterWrite, int maximumSize) {
       this.cacheName = cacheName;
       this.expiredAfterWrite = expiredAfterWrite;
       this.maximumSize = maximumSize;
   }

   private String cacheName;
   private int expiredAfterWrite;
   private int maximumSize;
}
```
## 📣캐싱 Config 설정
* `Caffeine Cache`를 적용하기 위해 `CacheConfig`설정
```java
@Configuration
@EnableCaching
public class CacheConfig {
    @Bean
    public CacheManager cacheManager() {
        SimpleCacheManager cacheManager = new SimpleCacheManager();
        List<CaffeineCache> caches = Arrays.stream(CacheType.values())
                .map(
                        cache -> new CaffeineCache(cache.getCacheName(),
                                Caffeine.newBuilder()
                                        .expireAfterWrite(cache.getExpiredAfterWrite(), TimeUnit.SECONDS)
                                        .maximumSize(cache.getMaximumSize())
                                        .build()
                        )
                )
                .collect(Collectors.toList());
        cacheManager.setCaches(caches);
        return cacheManager;
    }
}
```
## 💉maximumSize 옵션 
* `maximumSize` 옵션은 캐시에 포함될 수 있는 최대 항목수를 지정해줍니다.
* 즉, 캐시에 들어있는 데이터가 100를 넘지 않도록 제한 
* `maximumSize`의 크기가 초과되면 `Caffeine Cache`은 `TinyLFU`기반 정책을 사용해, 덜 자주 쓰이는 데이터를 자동으로 제거합니다.  

<img width="789" height="377" alt="Image" src="https://github.com/user-attachments/assets/4423ca90-58b9-4c34-aca3-447fbaacee29" />

## 🚬maximumSize 옵션 설정 안하면 ?
* 기본적으로 `Caffeine Cache`에서 `maximumSize`를 명시적으로 설정하지 않으면 `Caffeine Cache` 내에서 설정된 최대 크기를 가질 수 있는 캐시로 동작합니다.
* 이 경우 메모리 부족 또는 시스템 리소스 제한에 따라 캐시 크기가 제한되며 만약 캐시의 크기가 시스템 자원에 너무 많은 영향을 미치는 경우 서버의 성능이 저할될 수 있습니다.
* 따라서 캐시 크기를 제어하기 위해서는 적절한 `maximumSize`값을 설정하여 메모리나 성능에 부담을 줄일 수 있습니다.

## ⌚메서드에 적용 
* 서비스 계층에서 code를 조회하는 메서드에 캐시를 적용합니다. 
* `Key`는 파라미터 값이 되고 `value`는 값이 들어갑니다.
* `@Cacheable(cacheNames = "codeCache", key = "#codeId")` `key`는 명시적으로 이렇게 설정할 수 있으며 설정하지 않으면  첫 번쨰 파라미터 값이 `key`가 됩니다.
* 여러 파라미터가 있을 때는 `#param1` + '_' + `#param2`처럼 조합해서 사용할 수 있습니다.
```java
@Cacheable(cacheNames = "codeCache", key = "#codeId")
public StudyResponse selectStudyCode(String code) {
    Study study = generatorIdRepository.getStudyByCode(code)
            .orElseThrow(() -> new IllegalArgumentException("아무것도 없는 디?"));
    return new StudyResponse(study.getCode(), study.getName());
}
```

## 📉Cache(캐싱) 처리 후 Latency 측정 
* 처음으로 API 요청을 할때는 캐싱에 없기 때문에 DB에서 조회 한 다음 캐시에 저장합니다. 
* `514ms`걸렸습니다. 로그를 보면 `SELECT` 쿼리가 날라 갔습니다. 
* 두 번째 API 요청을 했을 떄는 값이 캐시에 있기 때문에 DB 쿼리를 날리지 않고 캐시에있는 값을 조회하여 넘겨줍니다.
* 처음 요청했을 때 보다 빠른 `7ms`가 걸렸고 로그에 `SELECT` 쿼리가 발생하지도 않아 DB 쿼리 비용도 절검 하였습니다.

<img width="1416" height="689" alt="Image" src="https://github.com/user-attachments/assets/bd8c708e-c64b-4241-9421-e005392c1f6f" />

## 🍟캐싱 적용한 값이 UPDATE 시 해결 법
> 데이터 변경이 자주 일어나면 캐시 데이터와 DB 데이터가 다를 수 있어 일관성 보장이 안됩니다.
### `@CachePut`캐싱 업데이트
* 캐싱이 적용된 값을 업데이트 할때 기존 캐시를 삭제하지 않고 새로운 값으로 업데이트 해줍니다.
* `@CachePut`은 메서드가 호출될 때마다 실행되고, 그 결과를 캐시에 강제로 저장합니다.
* 주로 캐시를 삭제하지 않고 바로 갱신하고 싶을 때 사용합니다.
```java

@CachePut(cacheNames = "codeCache", key = "#code")
public StudyResponse updateAndReturnStudy(String code, Study updatedStudy) {
    // 업데이트 로직
    return new StudyResponse(updatedStudy.getCode(), updatedStudy.getName());
}
```

### `@CacheEvict` 캐싱 삭제
* 캐싱이 적용된 값을 업데이트 할때는 `@CacheEvict`를 업데이트 메서드에 붙쳐 기존 캐시를 삭제해서 최신 데이터를 반영하게 합니다. 
* 이렇게 되면 `codeCache`에 저장된 해당 `code`키의 캐시가 삭제되고 
* 다음에 `@Cacheable`이 붙은 `selectStudyCode`가 호출될 때 새로 조회해서 캐시에 다시 저장됩니다.

```java
@CacheEvict(cacheNames = "codeCache", key = "#code")
public void updateStudy(String code, Study updatedStudy) {
    // 업데이트 로직
}
```
